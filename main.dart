import 'dart:io';
import 'dart:convert';
import 'dart:typed_data';    //Нужен для "Uint8List"

import 'TCP_Client__class.dart';





void main() async
{

  //---------------------------------------------------------------------TCP_Client__class:Начало-------------------------------------------------------------------------

  //Это небольшой класс обертка над чистыми TCP-сокетами в качестве Клиента, то есть для Передачи данных и возможного ответного приема от Получателя.

  //Доступные методы:
  //set__Shared_Callback_for_ConnectionStatus      - устанавливает обший для всех Сокетов Колбек, который будет вызыватся при изменеии состояния Соединения.
  //set__Shared_Callback_for_CloseSocket           - устанавливает обший для всех Сокетов Колбек, который будет вызыватся при закрытии Сокета.
  //set__Shared_Callback_for_Read                  - устанавливает обший для всех Сокетов Колбек, который будет вызыватся при чтении Входяших данных из Сокета.

  //add__NewSocket                                 - доавбляет новую структуру Сокета.
  //get__Socket_by_Name                            - возвращает стурктуру Сокета по его имени указанном при "add__NewSocket"
  //Connect                                        - устанавливает соединение на Сокете.
  //send__Bytes_to_socket                          - отправляет данные в Сокет.
  //set__ReadParamFlag_for_Socket                  - устанавливает режим чтения данных из Сокета.
  //set__ReadUntill_Seperator_for_Socket           - устанавливает "разделитель" для режима чтения "ReadUntill"
  //set__AccumulateBuffer_Size_for_Socket          - устанавливает размер буффера для режима чтения "AccumulateBuffer"
  //close_Socket                                   - закрывает Сокет.
  //destroy_Socket                                 - уничтожает Сокет.
  //close_AllSocket                                - закрывает все Сокеты.
  //destroy_AllSocket                              - уничтожает все Сокеты.
  //get__Socket_Close_status                       - возврашает статус Сокета: закрыт или открыт.


  //-------------------------------------------------------------------------------------------------------------------------------------------------------------------
  void Function(TCP_Client__class TCP_Client__class__ref, Socket_Struct? Socket_Struct__ref, String text_error) lambda_error_ = (TCP_Client__class TCP_Client__class__ref, Socket_Struct? Socket_Struct__ref, String text_error) async
  {

    //Данная функция будет вызыватся каждый раз для всех используемых Сокетов, как будут перехватыываться исключения/ошибки.
    //TCP_Client__class__ref - ссылка на сам обьект класса.
    //Socket_Struct__ref     - ссылка на структуру сокета.
    //text_error             - текст ошибки.

    if(Socket_Struct__ref != null)
    {
      print('${Socket_Struct__ref.Socket_name} Error_exeption: ${text_error}');
    }
    else
    {
      print('Error_exeption: ${text_error}');
    }

    //await TCP_Client__class__ref.destroy_Socket(Socket_Struct__ref, false);
  };


  TCP_Client__class TCP_Client_ = new TCP_Client__class(lambda_error_);   //Создаем обьект класса.
  //-------------------------------------------------------------------------------------------------------------------------------------------------------------------





  //-------------------------------------------------------------------1-set__Shared_Callback_for_ConnectionStatus:Begin------------------------------------------------------------------------------------------------

  //Устанавливает общий колбек для всех Используемых Сокетов. Данные колбек будет вызывается каждый раз, как будет устанавливатся или разрыватся Соединение на каком либо из используемых Сокетов.
  //Установка данного колбека не является обязательным.

  void Function(TCP_Client__class TCP_Client__class__ref, Socket_Struct Socket_Struct__ref, bool Connection_flag) lambda_for_ConnectionStatus = (TCP_Client__class TCP_Client__class__ref, Socket_Struct Socket_Struct__ref, bool Connection_flag)
  {

    //Данная функция будет вызыватся каждый раз для всех используемых Сокетов, как менятся статус уствноки соединения для Сокета.
    //TCP_Client__class__ref - ссылка на сам обьект класса.
    //Socket_Struct__ref     - ссылка на структуру сокета.
    //Connection_flag        - логический флаг соединения на Сокете "Socket_Struct__ref".

    if(Connection_flag == true)
    {
      print('${Socket_Struct__ref.Socket_name} :Connect');
    }
    else
    {
      print('${Socket_Struct__ref.Socket_name} :Disconect');
    }

  };

  TCP_Client_.set__Shared_Callback_for_ConnectionStatus(lambda_for_ConnectionStatus);

  //-------------------------------------------------------------------1-set__Shared_Callback_for_ConnectionStatus:End------------------------------------------------------------------------------------------------


  //-------------------------------------------------------------------2-set__Shared_Callback_for_CloseSocket:Begin------------------------------------------------------------------------------------------------

  //Устанавливает общий колбек для всех Используемых Сокетов. Данные колбек будет вызывается каждый раз, как будет закрыватся Сокет на каком либо из используемых Сокетов.
  //Установка данного колбека не является обязательным.

  Function(TCP_Client__class TCP_Client__class__ref, Socket_Struct Socket_Struct_ref) User_lambda_for_CloseSocket_ = (TCP_Client__class TCP_Client__class__ref, Socket_Struct Socket_Struct_ref)
  {

    //Данная функция будет вызыватся каждый раз для всех используемых Сокетов, в случае, если Сокет по какой либо причине закрывается.
    //TCP_Client__class__ref - ссылка на сам обьект класса.
    //Socket_Struct__ref     - ссылка на структуру сокета.

    print("Close_Socket:${Socket_Struct_ref.Socket_name}");
  };

  TCP_Client_.set__Shared_Callback_for_CloseSocket(User_lambda_for_CloseSocket_);

  //-------------------------------------------------------------------2-set__Shared_Callback_for_CloseSocket:End------------------------------------------------------------------------------------------------



  //-------------------------------------------------------------------------3-set__Shared_Callback_for_Read:Begin------------------------------------------------------------------------------------------------

  //Устанавливает общий колбек для всех Используемых Сокетов. Данные колбек будет вызывается каждый раз, как будет приходить Входящие данные на Сокет, то есть если Ответная строна(Получатель) отправит какое либо сообщение.
  //Установка данного колбека не является обязательным.

  void  Function(TCP_Client__class TCP_Client__class__ref, Socket_Struct Socket_Struct__ref, Uint8List Incoming_data) lambda_for_Read_from_Socket = (TCP_Client__class TCP_Client__class__ref, Socket_Struct Socket_Struct__ref, Uint8List Incoming_data)
  {
    //TCP_Client__class__ref - ссылка на сам обьект класса "TCP_Client__class", который вызовал данный колбек.
    //Socket_Struct__ref     - ссылка на структуру Сокета.
    //Incoming_data          - Буфер "Uint8List" с пришедшими Входящими данными доступными для чтения в данный момент. После завершения колбека ссылка на днные "Incoming_data" - становтся невалдиными, обращатся к ним уже Нельзя! Поэтому если нужно их сохранить - данные необхоимо ПЕРЕКОПИРОВАТЬ в свой буффер.

    print("${Socket_Struct__ref.Socket_name} : data_bytes_size: ${Incoming_data.length} : ${Incoming_data}");
    print('${Socket_Struct__ref.Socket_name} : data_bytes_size: ${Incoming_data.length} : ${utf8.decode(Incoming_data)}');   //Преобразуем данные из буффера в Dart`овский String(UTF-16), но при это нужно гарантированно знать, что в "data" находится валидная UTF-8 кодировка, иначе ошибка в рантайме.
  };


  TCP_Client_.set__Shared_Callback_for_Read(lambda_for_Read_from_Socket);

  //-------------------------------------------------------------------------3-set__Shared_Callback_for_Read:End------------------------------------------------------------------------------------------------



  //-----------------------------------------------------------------------------4-add__NewSocket:Begin------------------------------------------------------------------------------------------------

  //Метод создает/доавбляет новый сокет в контейнер сокетов.

  String Socket_name = "Socket_Name_1";   //Имя Сокета. Если не нужно, то можно передать пустую строку! НУЖЕН ЛИШЬ ДЛЯ УДОБНОГО ПОЛУЧЕНИЯ УКАЗАТЕЛЯ НА СТРУКТУРУ СОКЕТА "socket_struct*" - ПО ЕГО ИМЕНИ, ЕСЛИ ЭТО МОЖЕТ ПОНАДОБИТСЯ.  Но, если имя Сокета все таки указаывалось, то оно НЕ ДОЛЖНО ПОВТОРЯЮТСЯ С ДРУГИМИ ДОБАВЛЕННЫМИ ИМЕНАМИ СОКЕТОВ.

  Socket_Struct? Socket_Struct_ref_1 = TCP_Client_.add__NewSocket(Socket_name);      //Функция возвращает ссылку на добалвенную "структуру" Сокета.

  //-----------------------------------------------------------------------------4-add__NewSocket:End------------------------------------------------------------------------------------------------



  //-----------------------------------------------------------------------5-get__Socket_by_Name:Begin---------------------------------------------------------------------

  //Возвращает ссылку на "структуру" Сокета по имени указанному при вызове "add__NewSocket".

  Socket_Struct? Socket_Struct_ref_get = TCP_Client_.get__Socket_by_Name("Socket_Name_1");

  if(Socket_Struct_ref_get == null)
  {
    print("Socket_Name not Found");
  }
  //-----------------------------------------------------------------------5-get__Socket_by_Name:End---------------------------------------------------------------------



  //-------------------------------------------------------------------------------6-Connect:Begin------------------------------------------------------------------------------------------------

  //Метод устанавливает соединение на Сокете с Удаленным IP: как напрямую по IP, так и по web-адресу.
  //Можно использовать ранее добавленный Сокет, если даже он использовался для друого соединения, если Сокет не закрыт, то внутри "Connect" сначала закроется сокет, а потом вызовется на нм новое Соединение.

  //-------------------------------------------------------------------------------------------------------------------------------
  Function(TCP_Client__class TCP_Client__class__ref, Socket_Struct Socket_Struct_ref, bool Connection_flag)? Func_for_Socket_Connect = (TCP_Client__class TCP_Client__class__ref, Socket_Struct Socket_Struct_ref, bool Connection_flag)
  {
    //Функция которая будет вызыватся ТОЛЬКО ДЛЯ КОНКРЕТНОГО Сокета - указанного при вызове "Connect".
    //Данные колбек будет вызывается каждый раз, как будет устанавливатся или разрыватся Соединение на каком либо из используемых Сокетов.

    //TCP_Client__class__ref - ссылка на сам обьект класса "TCP_Client__class", который вызовал данный колбек.
    //Socket_Struct__ref     - ссылка на структуру Сокета.
    //Connection_flag        - логический флаг соединения на Сокете "Socket_Struct__ref".

    if(Connection_flag == true)
    {
      print('${Socket_Struct_ref.Socket_name} :Connect');
    }
    else
    {
      print('${Socket_Struct_ref.Socket_name} :Disconect');
    }
  };

  Function(TCP_Client__class TCP_Client__class__ref, Socket_Struct Socket_Struct_ref, Uint8List Incoming_data)? Func_for_Socket_Read = (TCP_Client__class TCP_Client__class__ref, Socket_Struct Socket_Struct_ref, Uint8List Incoming_data)
  {
    //Функция которая будет вызыватся ТОЛЬКО ДЛЯ КОНКРЕТНОГО Сокета - указанного при вызове "Connect".
    //Данные колбек будет вызывается каждый раз, как будет приходит Входящие данные на Сокет, то есть если Ответная строна(Получатель) отправит какое либо сообщение.

    //TCP_Client__class__ref - ссылка на сам обьект класса "TCP_Client__class", который вызовал данный колбек.
    //Socket_Struct__ref     - ссылка на структуру Сокета.
    //Incoming_data          - Буфер "Uint8List" с пришедшими Входящими данными доступными для чтения в данный момент. После завершения колбека ссылка на днные "Incoming_data" - становтся невалдиными, обращатся к ним уже Нельзя! Поэтому если нужно их сохранить - данные необхоимо ПЕРЕКОПИРОВАТЬ в свой буффер.

    print("${Socket_Struct_ref.Socket_name} : data_bytes_size: ${Incoming_data.length} : ${Incoming_data}");
    print('${Socket_Struct_ref.Socket_name} : data_bytes_size: ${Incoming_data.length} : ${utf8.decode(Incoming_data)}');   //Преобразуем данные из буффера в Dart`овский String(UTF-16), но при это нужно гарантированно знать, что в "data" находится валидная UTF-8 кодировка, иначе ошибка в рантайме.
  };


  //String IP_or_web_adress = "google.com";   //"127.0.0.1";
  String IP_or_web_adress = "127.0.0.1";      //"127.0.0.1", "::1";       Удаленный IP к которому нужно подключится или web_adress.
  int port = 1234;                            //Порт
  //-------------------------------------------------------------------------------------------------------------------------------


  await TCP_Client_.Connect(Socket_Struct_ref_1, IP_or_web_adress, port, Func_for_Socket_Connect, null);   //Если колбек-функции не нужны можно передать - null.
  //-------------------------------------------------------------------------------6-Connect:End------------------------------------------------------------------------------------------------






  //-------------------------------------------------------------------7-set__ReadParamFlag_for_Socket:Begin------------------------------------------------------------------------------------------------

  //Устанавливает на Сокете паарметр Чтения Входящих данных.

  //------------------------------------------------------
  Socket_Struct Socket_Struct_ref_3 = Socket_Struct_ref_1;        //Ранее полученная "структура" сокета - при доавблении нового сокета с помощью "add__NewSocket".

  read_flag read_flag_ = read_flag.Original_chunk;

  //Original_chunk     - Значит, что каждый Входящий буффер данных стразу будет отправлятся в Пользовательский колбек без каких либо дополнительных действий.
  //Accumulate_buffer  - Значит, что каждый Входящий буффер данных будет добовлятся в "_Read__AccumulateBuffer" буффер до указанного в "_Read__Accumulate_size" размера - при жостижении размера буффера >= "_Read__Accumulate_size" в колбек будет напарвлятся указатель на часть данных размером "_Read__Accumulate_size" и после колбека будет удалена.
  //Read_untill        - Значит, что каждый Входящий буффер данных будет добовлятся в "_Read__ReadUntill" до тех пор пока не будет найден заданный Пользователем "разделитель" после чего будет вызван Пользоватльеский колбек и после колбека данные до разделителя и сам разделитель будут удалены. То сть оповещение через установленные колбеки будет только тогда, когда во Входящих данных будет найден установленный разделитель с помощью "set__ReadUntill_Seperator_for_Socket". ТО ЕСТЬ: Пояснение: к примеру разделитель это символ "$", сам Входящий буффер содержит в моменте такие данные: 1234$56$789 - то есть в буффере присутствует ДВА разделителя и ТРИ разделенные подстроки, ТРЕТЬЮ подстроку "789" мы не трогаем и сообщаем о ней Пользователю через колбек, так как для нее еще не пришел свой разделитель. Мы его оставляет в буффере для следующего накопления данных и поиска разделителя. Для подстрок "1234" и "56" - будет вызвана два отдельных колбека.
  //------------------------------------------------------

  TCP_Client_.set__ReadParamFlag_for_Socket(Socket_Struct_ref_3, read_flag_);
  //-------------------------------------------------------------------7-set__ReadParamFlag_for_Socket:End------------------------------------------------------------------------------------------------







  //-------------------------------------------------------------------8-set__ReadUntill_Seperator_for_Socket:Begin------------------------------------------------------------------------------------------------

  //Устанавливает разделитель для параметра чтения "ReadUntill".

  //-----------------------------------------------------------------
  Socket_Struct Socket_Struct_ref_4 = Socket_Struct_ref_1;        //Ранее полученная "структура" сокета - при доавблении нового сокета с помощью "add__NewSocket".

  Uint8List separator = Uint8List.fromList(utf8.encode(","));
  //-----------------------------------------------------------------


  TCP_Client_.set__ReadUntill_Seperator_for_Socket(Socket_Struct_ref_4, separator);
  //-------------------------------------------------------------------8-set__ReadUntill_Seperator_for_Socket:End------------------------------------------------------------------------------------------------




  //-------------------------------------------------------------------9-set__AccumulateBuffer_Size_for_Socket:Begin------------------------------------------------------------------------------------------------

  //Устанавливает размер накопительного буффера для параметра чтения "AccumulateBuffer". По уомлчанию установлено значение 1024 байт.

  //-----------------------------------------------------------------
  Socket_Struct Socket_Struct_ref_4_ = Socket_Struct_ref_1;        //Ранее полученная "структура" сокета - при доавблении нового сокета с помощью "add__NewSocket".

  int AccumulateBuffer_Size = 100;
  //-----------------------------------------------------------------

  TCP_Client_.set__AccumulateBuffer_Size_for_Socket(Socket_Struct_ref_4_, AccumulateBuffer_Size);
  //-------------------------------------------------------------------9-set__AccumulateBuffer_Size_for_Socket:End------------------------------------------------------------------------------------------------





  //--------------------------------------------------------------------------10-send__Bytes_to_socket:Begin------------------------------------------------------------------------------------------------

  //Отправляет данные в Сокет для передачи по установленному соединению на удаленный IP. В случае если данный метод вызван ДО установления Соединения с удаленным IP - задача на отправку данных будет помещена в очередь ожидания, и данные буду тотправлены, когда бьудет установлено Соединение.

  //-----------------------------------------------------
  Socket_Struct Socket_Struct_ref_2 = Socket_Struct_ref_1;        //Ранее полученная "структура" сокета - при доавблении нового сокета с помощью "add__NewSocket".

  Uint8List Data_to_send = Uint8List.fromList(utf8.encode("GET / ,HTTP/1.1\r\nHost: google.com\r\n\r\n"));   //Сырой буффер данных Uint8 для отправки.     "Hello from Dart"

  bool copy_data_flag = true;    //Флаг копирования исходного Пользвотельского буффера "Data_to_send" во внутренний буффер класса. true - сделать копию буффера(с буффер "Data_to_send" можно делать все что угодно, после завершения вызова данного метода), false - неделать копию буффера(тогда буффер "Data_to_send" должен быть валидным до тех пор пока данные не отправятся)  Пояснение: Так как при передаче данных с помощью "add" - требуется, чтобы исходный буффер сохранялся и не изменялся на все время передачи, то, чтобы Пользователь не держал буффер сохранным можно сделать его копию внутри класса, который освободится сборщиком мусора, когда он уже будет ен нужен.
  //-----------------------------------------------------


  TCP_Client_.send__Bytes_to_socket(Socket_Struct_ref_2, Data_to_send, copy_data_flag);
  //--------------------------------------------------------------------------10-send__Bytes_to_socket:End------------------------------------------------------------------------------------------------




  //----------------------------------------------------------------------------11-close_Socket:Begin------------------------------------------------------------------------------------------------

  //Закрывает Сокет в Синхронном режиме. То есть функция вернется только тогда, когда Сокет будет закрыт.


  //------------------------------------------------------------------------------------
  Socket_Struct Socket_Struct_ref_5 = Socket_Struct_ref_1;        //Ранее полученная "структура" сокета - при доавблении нового сокета с помощью "add__NewSocket".

  bool flush_flag = true;                                         //true - значит перед закрытием Сокета, если во внутренних буфферах есть какие то данные для отправки они будут реализованы, и только потом Сокет будет закрыт.; false - Сокет закроется сразу без завершающих операций отправки, если они есть.

  bool erase_socket_flag = false;                                 //false - значит Сокет не будет удален из списка доавбленных сокетов, поэтому его можно переиспользовать после установки нового Соединения; true - значит сокет будет удален из списка доавбленных сокетов и обращатся к нему больше нельзя.
  //------------------------------------------------------------------------------------



  //await TCP_Client_.close_Socket(Socket_Struct_ref_5, flush_flag, erase_socket_flag);

  //----------------------------------------------------------------------------11-close_Socket:End------------------------------------------------------------------------------------------------



  //-----------------------------------------------------------------------12-destroy_Socket:Begin------------------------------------------------------------------------------------------------

  //Уничтожает сокет, при уничтожении Не ждет отправки всех данных, которые еще не отправлены, которые есть во внутреннем буффере.
  //И удаляем сокет из списка доабвленных сокетов, поэтому обращатся к нему больше нельзя.
  //Функция синхронная, то есть функция не завершится, пока Сокет не будет уничтожен.


  Socket_Struct Socket_Struct_ref_6 = Socket_Struct_ref_1;        //Ранее полученная "структура" сокета - при доавблении нового сокета с помощью "add__NewSocket".

  bool erase_socket_flag_1 = false;                                 //false - значит Сокет не будет удален из списка доавбленных сокетов, поэтому его можно переиспользовать после установки нового Соединения; true - значит сокет будет удален из списка доавбленных сокетов и обращатся к нему больше нельзя.

  //await TCP_Client_.destroy_Socket(Socket_Struct_ref_6, erase_socket_flag_1);
  //-----------------------------------------------------------------------12-destroy_Socket:End------------------------------------------------------------------------------------------------



  //-------------------------------------------------------------------------13-close_AllSocket:Begin------------------------------------------------------------------------------------------------

   //Закрывает все Сокеты, которые есть на момент вызова данного метода в списке доабвленных сокетов в Синхронном режиме. То есть функция вернется только тогда, когда Сокет будет закрыт.


  //------------------------------------------------------------------------------------
  bool flush_flag_1 = true;                                         //true - значит перед закрытием Сокета, если во внутренних буфферах есть какие то данные для отправки они будут реализованы, и только потом Сокет будет закрыт.; false - Сокет закроется сразу без завершающих операций отправки, если они есть.

  bool erase_socket_flag_ = false;                                 //false - значит Сокеты не будет удалены из списка доавбленных сокетов, поэтому его можно переиспользовать после установки нового Соединения; true - значит сокеты будет удалены из списка доавбленных сокетов и обращатся к нем больше нельзя.
  //------------------------------------------------------------------------------------


  //await TCP_Client_.close_AllSocket(flush_flag_1, erase_socket_flag_);

  //-------------------------------------------------------------------------13-close_AllSocket:End------------------------------------------------------------------------------------------------




  //----------------------------------------------------------------------14-destroy_AllSocket:Begin------------------------------------------------------------------------------------------------

  //Уничтожает Все Сокеты, при уничтожении Не ждет отправки всех данных, которые еще не отправлены, которые есть во внутреннем буффере.
  //И удаляем сокеты из списка доабвленных сокетов, поэтому обращатся к нем больше нельзя.
  //Функция синхронная, то есть функция не завершится, пока Все Сокеты не будет уничтожен.



  bool erase_socket_flag_2 = false;                                 //false - значит Сокет не будет удален из списка доавбленных сокетов, поэтому его можно переиспользовать после установки нового Соединения; true - значит сокет будет удален из списка доавбленных сокетов и обращатся к нему больше нельзя.

  //await TCP_Client_.destroy_AllSocket(erase_socket_flag_2);

  print("List_Socket_Size:${TCP_Client_.get__Socket_List_Size()}");
  //----------------------------------------------------------------------14-destroy_AllSocket:End------------------------------------------------------------------------------------------------


  //---------------------------------------------------------------------TCP_Client__class:Конец-------------------------------------------------------------------------




//---------------------------------------------------------------------TCP_Client__class:Begin-------------------------------------------------------------------------

  //Возвращает статус Закрытия Сокета;

  Socket_Struct Socket_Struct_ref_555 = Socket_Struct_ref_1;        //Ранее полученная "структура" сокета - при доавблении нового сокета с помощью "add__NewSocket".

  bool Close_status = TCP_Client_.get__Socket_Close_status(Socket_Struct_ref_555);

  if(Close_status == true)
  {
    print("Socket_Closed");
  }
  else
  {
    print("Socket_Open");
  }

//---------------------------------------------------------------------TCP_Client__class:Конец-------------------------------------------------------------------------



  //await Future.delayed(Duration(seconds: 2));

}


